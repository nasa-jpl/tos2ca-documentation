"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[640],{4380:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var t=s(2218),o=s(1879);const i={sidebar_position:3},a="ForTraCC Module",r={id:"fortracc-module",title:"ForTraCC Module",description:"The ForTraCC Module repository can be found at https://github.com/nasa-jpl/tos2ca-fortracc-module.",source:"@site/docs/fortracc-module.md",sourceDirName:".",slug:"/fortracc-module",permalink:"/docs/fortracc-module",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Anomaly Detection",permalink:"/docs/anomaly-detection"},next:{title:"Data Dictionaries",permalink:"/docs/data-dictionaries"}},d={},l=[{value:"Quickstart: Simple Thresholding Case",id:"quickstart-simple-thresholding-case",level:2},{value:"Overview",id:"overview",level:2},{value:"ForTraCC Implementation: <code>flow.py</code>",id:"fortracc-implementation-flowpy",level:3},{value:"ForTraCC Objects: <code>objects.py</code>",id:"fortracc-objects-objectspy",level:3},{value:"NetCDF Format",id:"netcdf-format",level:2}];function c(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"fortracc-module",children:"ForTraCC Module"})}),"\n",(0,t.jsxs)(n.p,{children:["The ForTraCC Module repository can be found at ",(0,t.jsx)(n.a,{href:"https://github.com/nasa-jpl/tos2ca-fortracc-module",children:"https://github.com/nasa-jpl/tos2ca-fortracc-module"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"#",children:(0,t.jsx)(n.img,{src:"https://img.shields.io/badge/python-3.9-blue",alt:"Language"})})}),"\n",(0,t.jsxs)(n.p,{children:["The ForTraCC Module contains tools to implement the\n",(0,t.jsx)(n.a,{href:"http://mtc-m16b.sid.inpe.br/col/sid.inpe.br/mtc-m15@80/2008/06.02.17.27/doc/ForTraCC_Published.pdf",children:"ForTraCC algorithm"}),"\nnatively in Python without the need of the original Fortran code.  There are slight differences between the Python and\nFortran implementations, but overall, the Python implementation accomplishes the same task.  Compare the plots in\n",(0,t.jsx)(n.code,{children:"python_outputs"})," and ",(0,t.jsx)(n.code,{children:"fortran_outputs"})," for more details."]}),"\n",(0,t.jsx)(n.p,{children:"ForTraCC works by first identifying a phenomenon with a series of masks(0 - background, 1 - phenomenon) and then\nstitching the temporally disparate phenomena together into a time series based on overlaps between consecutive masks.\nAn isolated phenomenon is defined by spatially grouping together connected components of a mask\nand temporally linking other connected components by their consecutive overlaps.  For example, in its original\nimplementation, ForTraCC was used to track mesoscale convective systems that evolve over time where each isolated\nsystem is a phenomenon.  The original algorithm also included a forecasting component which was meant to predict\nfuture phenomenon, but this feature is not implemented here."}),"\n",(0,t.jsx)(n.h2,{id:"quickstart-simple-thresholding-case",children:"Quickstart: Simple Thresholding Case"}),"\n",(0,t.jsxs)(n.p,{children:["For a full example script(visualization included) of this case see ",(0,t.jsx)(n.code,{children:"tutorial.py"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Suppose we are given a time-ordered series of 2D images stored as a list of 2D numpy arrays.  If we want to represent\na particular phenomenon by thresholding the values of the images, we can apply ForTraCC with"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from fortracc_python.flow import ThresholdEvent\nfrom fortracc_python.objects import GeoGrid\n\ngrid = GeoGrid(\n    latitude,  # The latitude given as a list of numbers(must match number of rows in `images`)\n    longitude  # The longitude given as a list of numbers(must match number of columns in `images`)\n)\nphenomenon = ThresholdEvent(\n    images,  # A list of 2D, time-ordered images to use\n    timestamps,  # The datetime of each image given as a list of strings\n    grid,  # The grid object on which each image is defined\n    threshold  # The threshold below which a pixel is marked as a phenomenon\n)\ntime_series = phenomenon.run_fortracc()\n"})}),"\n",(0,t.jsx)(n.p,{children:"For defining phenomenon with more than just a single threshold, see the next section below."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["There are two main modules: ",(0,t.jsx)(n.code,{children:"flow.py"})," and ",(0,t.jsx)(n.code,{children:"objects.py"}),".  The former contains Python classes for running ForTraCC whereas\nthe latter contains a few useful classes for defining phenomenon.  In this section, we run through the main classes and\ndiscuss how they may be modified as a part of a larger pipeline."]}),"\n",(0,t.jsxs)(n.h3,{id:"fortracc-implementation-flowpy",children:["ForTraCC Implementation: ",(0,t.jsx)(n.code,{children:"flow.py"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"flow.py"})," has two classes: A base class ",(0,t.jsx)(n.code,{children:"TimeOrderedSequence"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class TimeOrderedSequence:\n    """\n    Object used to convert a sequence of provided masks into a time series of events.  Each event is\n    spatially defined as a connected component of a mask and temporally linked to other connected components\n    through the ForTraCC algorithm(Vila, Daniel Alejandro, et al. "Forecast and Tracking the Evolution\n    of Cloud Clusters (ForTraCC) using satellite infrared imagery: Methodology and validation." Weather\n    and Forecasting 23.2 (2008): 233-245.).\n    """\n    def __init__(\n            self,\n            masks: List[np.array],\n            timestamps: List[str],\n            grid: GeoGrid\n    ):\n        """\n        :param List[np.array] masks: A list of masks defining a phenomenon each given as an np.array.\n        :param List[str] timestamps: A list of timestamps with the same size as `masks` where each item is a\n                                     string formatted as YYYYMMDDhhmm(e.g. 201501011430) giving the datetime of the\n                                     corresponding mask.\n        :param GeoGrid grid: A GeoGrid object that defines the geographical grid on which the masks live.\n        """\n'})}),"\n",(0,t.jsxs)(n.p,{children:["and a custom class ",(0,t.jsx)(n.code,{children:"ThresholdEvent"})," which defines a phenomenon with a single threshold"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class ThresholdEvent(TimeOrderedSequence):\n    """\n    Specific TimeOrderedSequence object that defines phenomenon based on a threshold.  Any pixel that is\n    less than the provided threshold is treated as a part of the phenomenon.\n    """\n    def __init__(\n            self,\n            images: List[np.array],\n            timestamps: List[str],\n            grid: GeoGrid,\n            threshold: float\n    ):\n        """\n        :param List[np.array] images: A list of images given as np.arrays.  Each pixel should have the same units\n                                      as the provided threshold.\n        :param List[str] timestamps: A list of timestamps with the same size as `masks` where each item is a\n                                     string formatted as YYYYMMDDhhmm(e.g. 201501011430) giving the datetime of the\n                                     corresponding mask.\n        :param GeoGrid grid: A GeoGrid object that defines the geographical grid on which the masks live.\n        :param float threshold: The threshold below which a phenomenon is defined.  The threshold should have the\n                                same units as the values in `images`.\n        """\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Looking at the base class, all that is needed to run ForTraCC is a time-ordered list of masks(0 - background,\n1 - phenomenon).  If a particular phenomenon requires more complicated transformations of the native satellite images,\nthen all that needs to be done is to create a class that generates the phenomenon masks from the original images and pass\nthese masks to ",(0,t.jsx)(n.code,{children:"TimeOrderedSequence"}),", either by class inheritance or by explicit instantiation."]}),"\n",(0,t.jsx)(n.p,{children:"For example, let's quickly create a class which defines a phenomenon with two threshols instead of just one"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class DoubleThresholdEvent(TimeOrderedSequence):\n    def __init__(\n            self,\n            images: List[np.array],\n            timestamps: List[str],\n            grid: GeoGrid,\n            threshold1: float,\n            threshold2: float\n    ):\n        masks = [(threshold1 < image) & (image < threshold2) for image in images]\n        super().__init__(masks, timestamps, grid)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This also facilitates more complicated definitions of masks such as those based on the anomaly or comparisons with\nhigher-order moments calculated from the native images."}),"\n",(0,t.jsxs)(n.h3,{id:"fortracc-objects-objectspy",children:["ForTraCC Objects: ",(0,t.jsx)(n.code,{children:"objects.py"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"objects.py"})," contains two useful classes for ForTraCC.  The first, ",(0,t.jsx)(n.code,{children:"GeoGrid"}),", is(for now) a glorified dictionary\nthat houses all the geographical information of an image."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class GeoGrid:\n    """\n    Object used to store geographical lat/lon coordinates.  For now it\'s a glorified dictionary.\n    """\n    def __init__(\n            self,\n            latitude: List,\n            longitude: List\n    ):\n        """\n        :param List latitude: The latitude for each pixel on a grid given as a vector.\n        :param List longitude: The longitude for each pixel on a grid given as a vector.\n        """\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The second class, ",(0,t.jsx)(n.code,{children:"Scene"}),", is useful for representing the connected components of a single image."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class Scene:\n    """\n    Object used for describing a phenomenon defined by a mask.  Stores individual "events"\n    as connected components of the provided mask and filters out events below a certain size\n    (total number of pixels in connected component).\n    """\n    def __init__(\n            self,\n            mask: np.array,\n            timestamp: Optional[str] = None,\n            connectivity: Optional[int] = 2,\n            min_size: Optional[int] = 1\n    ):\n        """\n        :param np.array mask: True/False mask describing a phenomenon.\n        :param str timestamp: A string formatted as YYYYMMDDhhmm(e.g. 201501011430) giving the datetime of the\n                              provided mask.\n        :param int connectivity: Determines how nearest neighbors are chosen when building connected components.\n                                 Choosing 1 selects top/bottom, left/right neighbors whereas 2 includes\n                                 the diagonals as well.\n        :param int min_size: Smallest size connected component(total number of pixels) to include as an "event".\n        """\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Let's focus on ",(0,t.jsx)(n.code,{children:"Scene"})," since ",(0,t.jsx)(n.code,{children:"GeoGrid"})," is extremely simple.  ",(0,t.jsx)(n.code,{children:"Scene"})," uses ",(0,t.jsx)(n.code,{children:"skimage.measure"})," to delineate the connected\ncompenents of the provided mask.  Once the connected components are defined, they are passed to\n",(0,t.jsx)(n.code,{children:"skimage.measure.regionprops"})," which calculates a myriad of properties for each of the connected components(for a full\nlist of the properties, see ",(0,t.jsx)(n.a,{href:"https://scikit-image.org/docs/stable/api/skimage.measure.html#skimage.measure.regionprops",children:"https://scikit-image.org/docs/stable/api/skimage.measure.html#skimage.measure.regionprops"}),").",(0,t.jsx)(n.br,{}),"\n","These properties may come in handy later down the line, but for now, the only useful one is ",(0,t.jsx)(n.code,{children:"area"})," which gives the total\npixel count of the connected component."]}),"\n",(0,t.jsx)(n.h2,{id:"netcdf-format",children:"NetCDF Format"}),"\n",(0,t.jsx)(n.p,{children:"The netCDF read/write utils are located in fortracc-module/utils.py.  The file structure is as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"|- root\n    |- navigation\n    |- masks\n         |- <timestamp 1>\n         |- <timestamp 2>\n         |-     ...\n         |- <timestamp T>\n"})}),"\n",(0,t.jsx)(n.p,{children:"The root of the file has the following format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"root group (NETCDF4 data model, file format HDF5):\n    event_type: less_than_threshold\n    latitude_bounds: [-19.99393463   4.96664858]\n    longitude_bounds: [-69.97372437 -30.03031921]\n    start_date: 201508120000\n    end_date: 201508120530\n    dimensions(sizes): \n    variables(dimensions): \n    groups: navigation, masks\n"})}),"\n",(0,t.jsx)(n.p,{children:"For the global information:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"event_type"}),":  This is the name of the event which is stored as a class variable for each of the event types(e.g. ",(0,t.jsx)(n.code,{children:"LessThanEvent"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"latitude_bounds"}),":  The min/max latitudes covering the region."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"longitude_bounds"}),":  The min/max longitudes covering the region."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"start_date"}),":  The starting date for data collection given as YYYYMMDDhhmm."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"end_date"}),":  The end date for data collection given as YYYYMMDDhhmm."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["From here, the data is separated into two groups: ",(0,t.jsx)(n.code,{children:"navigation"})," and ",(0,t.jsx)(n.code,{children:"masks"}),".  The first contains the lat/lon vectors that cover the region"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"<class 'netCDF4._netCDF4.Group'>\ngroup /navigation:\n    dimensions(sizes): lat(687), lon(1099)\n    variables(dimensions): float32 lat(lat), float32 lon(lon)\n    groups: \n"})}),"\n",(0,t.jsxs)(n.p,{children:["with variables ",(0,t.jsx)(n.code,{children:"lat"})," and ",(0,t.jsx)(n.code,{children:"lon"}),".  The second group contains the masks which are separated for each time step"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"<class 'netCDF4._netCDF4.Group'>\ngroup /masks:\n    num_events: 30\n    dimensions(sizes): \n    variables(dimensions): \n    groups: 201508120000, 201508120030, 201508120100, 201508120130, 201508120200, 201508120230, 201508120300, 201508120330, 201508120400, 201508120430, 201508120500, 201508120530\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here, the total number of events are given by the ",(0,t.jsx)(n.code,{children:"num_events"})," attribute.  To access the masks themselves, we need to select a timestamp from the group which leads to"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"<class 'netCDF4._netCDF4.Group'>\ngroup /masks/201508120000:\n    dimensions(sizes): num_pixels(12898), num_cols(3)\n    variables(dimensions): int32 mask_indices(num_pixels, num_cols)\n    groups: \n"})}),"\n",(0,t.jsxs)(n.p,{children:["The mask is finally acessed with the ",(0,t.jsx)(n.code,{children:"mask_indices"})," variable which is an N x 3 array where each row gives the (",(0,t.jsx)(n.code,{children:"row_index"}),", ",(0,t.jsx)(n.code,{children:"col_index"}),", ",(0,t.jsx)(n.code,{children:"event_id"}),") for each phenomenon.  The total size of the mask can be determined from the sizes of ",(0,t.jsx)(n.code,{children:"lat"})," and ",(0,t.jsx)(n.code,{children:"lon"}),".  Then these indices can be used to reconstruct the full mask.  See ",(0,t.jsx)(n.code,{children:"read_nc4"})," in ",(0,t.jsx)(n.code,{children:"fortracc-module/utils.py"})," for details."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1879:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var t=s(3746);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);